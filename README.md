# Floppa os 2
На текущем этапе 4 января 2026 **Floppa OS** поддерживает следующий набор возможностей:

### Базовые функции ядра

1. **Инициализация системы**  
   - Загрузка через GRUB (Multiboot‑совместимый загрузчик).
   - Настройка защищённого режима x86‑32.
   - Инициализация страничной памяти (`paging`).
   - Управление кучей (`malloc`/`free`).

2. **Вывод на экран**  
   - Базовый VGA‑драйвер: печать текста в текстовом режиме.
   - Цвета символов (через атрибут байта).

3. **Обработка ввода**  
   - Драйвер клавиатуры (PS/2, прерывания).
   - Чтение нажатий клавиш (упрощённо).

---

### Файловая система (FAT12)

4. **Доступ к носителю**  
   - Чтение секторов диска через BIOS INT 13h.
   - Поддержка флоппи‑дисков (1,44 МБ) или образов `.img`.
5. **Парсинг FAT12**  
   - Разбор BPB (BIOS Parameter Block).
   - Поиск файлов в корневом каталоге по имени.
6. **VFS (виртуальная ФС)**  
   - Абстрактный слой для работы с файлами.
   - Системные вызовы:  
     - `sys_open(path, flags)` — открытие файла.
     - `sys_read(fd, buf, count)` — чтение данных.

---

### Многозадачность (кооперативная)

7. **Управление задачами**  
   - Создание задач через `task_create(func)`.
   - Каждая задача получает собственный стек (4 КБ).
   - Идентификаторы процессов (`pid`).
8. **Планировщик**  
   - Круговой алгоритм (`round‑robin`): задачи выполняются по очереди.
   - Добровольная передача управления через `sys_task_yield()`.
9. **Переключение контекста**  
   - Сохранение/восстановление регистров CPU (ассемблер).
   - Поддержка до 32 задач одновременно.

---

### Системные вызовы (syscalls)

10. **Доступные syscalls**  
    - `SYS_WRITE` — вывод в консоль (через VGA).
    - `SYS_OPEN` / `SYS_READ` — работа с файлами.
    - `SYS_TASK_CREATE` — создание новой задачи.
    - `SYS_TASK_YIELD` — передача управления планировщику.

---

### Утилиты и инструменты

11. **Сборка системы**  
    - `Makefile` для компиляции C/ассемблерных файлов.
    - Линкер‑скрипт `link.ld` (точка входа `start`).
12. **Создание образа ФС**  
    - Скрипт `tools/mkfat12.py` генерирует образ FAT12 (1,44 МБ).
    - Возможность записи файлов в образ (вручную или через доп. скрипты).

---

### Что можно *сделать* в Floppa OS сейчас

- **Запустить ядро** в эмуляторе (QEMU, Bochs) или на реальном железе (с флоппи‑образом).
- **Вывести текст** на экран через `vga_write()` или `sys_write()`.
- **Прочитать файл** с диска:  
  ```c
  int fd = sys_open("hello.txt", 0);
  char buf[100];
  sys_read(fd, buf, 100);
  ```
- **Создать параллельные задачи**:  
  ```c
  task_create(task1);
  task_create(task2);
  // Обе задачи будут выполняться по очереди
  ```
- **Организовать простой GUI‑подобный цикл**:  
  - Одна задача обновляет экран.
  - Другая обрабатывает ввод с клавиатуры.
  - Третья выполняет вычисления.

---

### Чего *пока нет* (планы на развитие)

- **Вытесняющая многозадачность** (нужен таймер и IRQ).
- **Защита памяти** (нет изоляции процессов).
- **Файловые права и директории** (только корневой каталог FAT12).
- **Сетевые возможности**.
- **Драйверы** (кроме VGA и клавиатуры).
- **Пользовательское пространство** (всё работает в режиме ядра).


---

### Пример использования

```c
void task1() {
    while (1) {
        vga_write("Task 1 running\n", 0x0F);
        sys_task_yield();
    }
}

void task2() {
    while (1) {
        vga_write("Task 2 running\n", 0x0C);
        sys_task_yield();
    }
}

void kernel_main() {
    task_init();
    task_create(task1);
    task_create(task2);
    while (1) schedule();
}
```

**Результат**: На экране будут попеременно появляться строки от двух задач.

---
# Команды в консоли
В текущей реализации консоли **Floppa OS** доступны следующие команды:


1. **`help`**  
   - **Назначение**: выводит список всех доступных команд.  
   - **Пример**:  
     ```
     floppa-os $ help
     ```
   - **Вывод**: перечисляет все команды с кратким описанием.

2. **`reboot`**  
   - **Назначение**: перезагружает систему.  
   - **Пример**:  
     ```
     floppa-os $ reboot
     ```
   - **Эффект**: аппаратная перезагрузка через BIOS‑прерывание `int 0x19`.

3. **`ls`**  
   - **Назначение**: показывает файлы в корневом каталоге (упрощённая реализация FAT12).  
   - **Пример**:  
     ```
     floppa-os $ ls
     ```
   - **Вывод**: список файлов (например, `file1.txt`, `kernel.bin`).


4. **`clear`**  
   - **Назначение**: очищает экран консоли.  
   - **Пример**:  
     ```
     floppa-os $ clear
     ```
   - **Эффект**: экран становится пустым, появляется новая строка приглашения.

5. **`echo`**  
   - **Назначение**: выводит на экран указанные аргументы.  
   - **Пример**:  
     ```
     floppa-os $ echo Hello Floppa
     ```
   - **Вывод**:  
     ```
     Hello Floppa
     ```

6. **`cat`**  
   - **Назначение**: отображает содержимое текстового файла.  
   - **Пример**:  
     ```
     floppa-os $ cat hello.txt
     ```
   - **Вывод**: текст из файла `hello.txt` (если файл существует).  
   - **Ошибка**: если файл не найден, выводит сообщение об ошибке.

7. **`pwd`**  
   - **Назначение**: показывает текущий рабочий путь.  
   - **Пример**:  
     ```
     floppa-os $ pwd
     ```
   - **Вывод**: `/` (в текущей реализации ФС нет вложенных директорий).


8. **`date`**  
   - **Назначение**: выводит текущую дату и время (считывает из CMOS‑часов).  
   - **Пример**:  
     ```
     floppa-os $ date
     ```
   - **Вывод**:  
     ```
     2026-01-04 18:33:46
     ```

---

### Краткие значения

| Команда | Назначение |
|--------|-----------|
| `help` | Показать список команд |
| `reboot` | Перезагрузить систему |
| `ls` | Список файлов в корне |
| `clear` | Очистить экран |
| `echo` | Вывести текст |
| `cat` | Показать содержимое файла |
| `pwd` | Текущий путь (`/`) |
| `date` | Текущая дата/время |
| `floppa` | выводит шлёпу |
---
### Инструкция по модификации Floppa OS

Этот гайд поможет вам безопасно вносить изменения в систему. **Сохраняйте резервные копии** перед любыми правками!

---

### 1. Подготовка среды разработки

**Что нужно установить:**
- `i686-elf-gcc` (кросс‑компилятор);
- `binutils` (для линковки);
- `qemu` (эмулятор для тестирования);
- `grub2-mkrescue` (для сборки ISO).

**Команды для Ubuntu/Debian:**
```bash
sudo apt install build-essential qemu-system-i386 grub2-common
```

---

### 2. Структура проекта (ключевые папки)

```
floppa-os/
├── kernel/          # Код ядра (C/ASM)
│   ├── drivers/     # Драйверы (VGA, клавиатура, диск)
│   └── main.c       # Точка входа ядра
├── boot/           # Загрузчик и линкер‑скрипты
│   ├── linker.ld    # Скрипт линковки ядра
│   └── grub/        # Конфигурация GRUB
├── include/        # Заголовочные файлы
├── fs/             # Файловая система
└── iso/            # Временная папка для ISO
```

---

### 3. Как изменить ядро

**Шаг 1.** Откройте `kernel/main.c`  
**Шаг 2.** Внесите правки (например, добавьте вывод текста):
```c
void kernel_main() {
    vga_write("Floppa OS v2.0\n", 0x0F); // Новый текст и цвет
    // Ваш код здесь
}
```
**Шаг 3.** Пересоберите ядро:
```bash
i686-elf-gcc -c kernel/main.c -o bin/kernel.o -ffreestanding -m32
i686-elf-ld -T boot/linker.ld -o bin/kernel.bin bin/kernel.o
```

**Важно:**  
- Не удаляйте `_start` — это точка входа ядра.  
- Используйте `-ffreestanding` для отключения `libc`.

---

### 4. Как добавить новый драйвер

**Пример: драйвер для мыши**  
1. Создайте файл `kernel/drivers/mouse.c`.  
2. Реализуйте функции (например, `mouse_init()`, `mouse_read()`).  
3. Добавьте `#include "drivers/mouse.h"` в `kernel/main.c`.  
4. Вызовите `mouse_init()` в `kernel_main()`.  
5. Пересоберите ядро (см. шаг 3).

---

### 5. Как добавить новую команду в консоль

1. В `kernel/shell/commands.c` добавьте функцию:
```c
void cmd_hello(int argc, char **argv) {
    shell_puts("Hello from Floppa OS!\n");
}
```
2. Обновите массив `commands[]`:
```c
{"hello", cmd_hello},
```
3. Пересоберите и проверьте в консоли:
```
floppa-os $ hello
```

---

### 6. Как изменить загрузочный экран


1. Подготовьте изображение:  
   - Формат: RAW (320×200, 256 цветов) или BMP.  
   - Сохраните как `bootscreen.raw` в корне проекта.  
2. В `kernel/main.c` измените путь в `draw_boot_screen()`:
```c
draw_boot_screen("/bootscreen.raw");
```
3. Пересоберите ISO (см. раздел 8).

---

### 7. Как обновить файловую систему


1. Добавьте файлы в `iso/` (например, `iso/home/user.txt`).  
2. Пересоздайте ISO (раздел 8).  
3. Проверьте в QEMU:
```bash
qemu-system-i386 -cdrom bin/floppa_os.iso
```

---

### 8. Как пересобрать ISO‑образ


1. Скопируйте ядро в `iso/`:
```bash
cp bin/kernel.bin iso/boot/kernel.bin
```
2. Создайте ISO:
```bash
grub-mkrescue -o bin/floppa_os.iso iso/
```
3. Запустите для проверки:
```bash
qemu-system-i386 -cdrom bin/floppa_os.iso -m 64M
```

---

### 9. Отладка и тестирование


**Способы проверки:**  
1. **QEMU с отладкой**:  
   ```bash
   qemu-system-i386 -cdrom bin/floppa_os.iso -d int -D qemu.log
   ```
   (лог прерываний сохранится в `qemu.log`).  

2. **Вывод в консоль**:  
   Используйте `vga_write()` для промежуточных сообщений.  

3. **Проверка бинарника**:  
   ```bash
   objdump -D bin/kernel.bin | less
   ```

---

### 10. Частые ошибки и их решение


- **«Kernel panic: No shell task»**  
  → Проверьте `task_create(shell_task)` в `kernel_main()`.

- **«File not found»**  
  → Убедитесь, что файл есть в `iso/` и путь указан верно.
- **«Segmentation fault»**  
  → Добавьте проверки на `NULL` в коде.
- **«ISO не загружается»**  
  → Перепроверьте `grub.cfg` и путь к `kernel.bin`.
- **«Загрузочный диск не виден»**  
  → Покормите шлёпу.


---

### 11. Рекомендации


1. **Резервируйте изменения**:  
   Используйте Git:
   ```bash
   git init
   git add .
   git commit -m "Initial commit"
   ```
2. **Тестируйте после каждого шага** — не вносите много правок сразу.  
3. Читайте документацию:  
   - [OSDev Wiki](https://wiki.osdev.org)  
   - [GRUB Manual](https://www.gnu.org/software/grub/)  

---
Ошибка `i686-elf-gcc: команда не найдена` означает, что в вашей системе **не установлен кросс‑компилятор** для целевой платформы `i686-elf` (32‑битная x86 без ОС).


Ниже — пошаговая инструкция по установке.

---

### 1. Почему нужен кросс‑компилятор?


Ваш хост‑компьютер (например, x86_64 Linux) и целевое ядро ОС (32‑битное i686) имеют разную архитектуру. Поэтому:
- нельзя использовать обычный `gcc` (он генерирует код для хоста);
- нужен **кросс‑компилятор** `i686-elf-gcc`, который создаёт 32‑битный код без зависимостей от ОС.


---

### 2. Установка кросс‑компилятора (Linux)


#### Вариант 1: Через пакетный менеджер (проще)

Для Ubuntu/Debian:
```bash
sudo apt update
sudo apt install gcc-multilib
```
Это установит базовый мультиархитектурный GCC (может подойти для простых ядер).


Для более полного набора (binutils + gcc для i686‑elf):
```bash
sudo apt install binutils-i686-linux-gnu gcc-i686-linux-gnu
```

#### Вариант 2: Сборка из исходников (рекомендуется для OSDev)

1. **Создайте рабочую директорию**  
   ```bash
   mkdir ~/os-dev && cd ~/os-dev
   ```

2. **Установите зависимости**  
   Для Ubuntu/Debian:  
   ```bash
   sudo apt install build-essential bison flex libgmp3-dev libmpc-dev libmpfr-dev texinfo
   ```
   Для Fedora/RHEL:  
   ```bash
   sudo dnf install gcc make bison flex gmp-devel mpfr-devel libmpc-devel texinfo
   ```

3. **Скачайте исходники binutils и GCC**  
   ```bash
   wget https://ftp.gnu.org/gnu/binutils/binutils-2.39.tar.gz
   wget https://ftp.gnu.org/gnu/gcc/gcc-13.2.0/gcc-13.2.0.tar.gz
   ```
   (версии могут меняться — проверяйте актуальные на gnu.org)

4. **Распакуйте архивы**  
   ```bash
   tar -xf binutils-2.39.tar.gz
   tar -xf gcc-13.2.0.tar.gz
   ```

5. **Соберите binutils**  
   ```bash
   mkdir build-binutils && cd build-binutils
   ../binutils-2.39/configure --target=i686-elf --prefix=$HOME/os-dev/cross --disable-nls --enable-shared
   make -j$(nproc)
   make install
   ```

6. **Соберите GCC**  
   ```bash
   mkdir build-gcc && cd build-gcc
   ../gcc-13.2.0/configure --target=i686-elf --prefix=$HOME/os-dev/cross --disable-nls --enable-languages=c,c++ --without-headers --with-newlib --disable-multilib --disable-shared --disable-threads --disable-libstdcxx --disable-libssp
   make all-gcc -j$(nproc)
   make all-target-libgcc -j$(nproc)
   make install-gcc -j$(nproc)
   make install-target-libgcc -j$(nproc)
   ```

7. **Добавьте путь в `PATH`**  
   ```bash
   export PATH=$HOME/os-dev/cross/bin:$PATH
   ```
   Чтобы сохранить навсегда, добавьте строку в `~/.bashrc` или `~/.zshrc`.


8. **Проверьте установку**  
   ```bash
   i686-elf-gcc --version
   i686-elf-ld --version
   ```

---

### 3. Альтернативные способы (быстрые)


#### Для Ubuntu/Debian (готовые пакеты)
```bash
sudo add-apt-repository universe
sudo apt update
sudo apt install gcc-i686-elf
```


#### Через Homebrew (macOS)
```bash
brew install i686-elf-gcc
```

#### Готовые бинарники
Скачайте предварительно собранные инструменты:  
- [OSDev GCC Binaries](https://wiki.osdev.org/GCC_Cross-Compiler)  
- Распакуйте и добавьте путь к `bin/` в `PATH`.


---

### 4. Проверка работы


Создайте тестовый файл `test.c`:
```c
void _start() {
    while (1);
}
```

Скомпилируйте:
```bash
i686-elf-gcc -c test.c -o test.o -ffreestanding -m32
i686-elf-ld -T linker.ld -o kernel.bin test.o
```
где `linker.ld` — ваш линкер‑скрипт (как в предыдущем ответе).


Если ошибок нет — кросс‑компилятор работает.

---

### 5. Типичные ошибки и решения


- **Ошибка `command not found` после установки**:  
  Убедитесь, что путь к `cross/bin` добавлен в `PATH` (проверьте `echo $PATH`).


- **GCC не находит `stdio.h`**:  
  Не подключайте стандартные библиотеки (`-nostdinc`, `-ffreestanding`).


- **Ошибки линковки**:  
  Проверьте, что `linker.ld` указывает правильный адрес загрузки (например, `0x100000`).


